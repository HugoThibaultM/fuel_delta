import mmap
import struct
import time

def escanner_total():
    print("--- BUSCADOR DE SEÃ‘AL LMU ---")
    
    # LISTA COMPLETA de todos los nombres posibles que usa el plugin en 2024/2025
    posibles_nombres = [
        "$rFactor2SMMP_Telemetry$",   # <--- La mÃ¡s probable en versiones nuevas
        "$rFactor2SMMP_Scoring$",
        "$rFactor2Shared$",           # La clÃ¡sica
        "$rFactor2Extended$",
        "Local\\$rFactor2SMMP_Telemetry$",
        "Global\\$rFactor2SMMP_Telemetry$",
        "Local\\$rFactor2Shared$",
        "Global\\$rFactor2Shared$"
    ]

    mapas_vivos = []

    print("1. Buscando canales activos...")
    for nombre in posibles_nombres:
        try:
            # Intentamos abrir sin crear (si falla, es que no existe)
            shmem = mmap.mmap(-1, 16000, nombre, access=mmap.ACCESS_READ)
            
            # Leemos para ver si hay vida (no solo ceros)
            shmem.seek(0)
            data = shmem.read(100)
            es_cero = all(b == 0 for b in data)
            
            if not es_cero:
                print(f"   âœ… Â¡BINGO! Datos detectados en: '{nombre}'")
                mapas_vivos.append((nombre, shmem))
            else:
                # Si conecta pero estÃ¡ vacÃ­o, lo ignoramos (es el seÃ±uelo)
                shmem.close()
                print(f"   âš ï¸  Encontrado '{nombre}' pero estÃ¡ VACÃO (SeÃ±uelo).")

        except FileNotFoundError:
            pass
        except PermissionError:
            print(f"   â›” Permiso denegado en '{nombre}' (Ejecuta como Admin)")

    if not mapas_vivos:
        print("\nâŒ NO SE ENCONTRÃ“ NADA. AsegÃºrate de que SimHub sigue moviendo las agujas.")
        return

    print("\n2. Mostrando datos del canal ganador:")
    nombre_ganador, shmem_ganadora = mapas_vivos[0]
    
    try:
        while True:
            shmem_ganadora.seek(0)
            # Leemos un bloque grande para asegurar
            buff = shmem_ganadora.read(64)
            
            # InterpretaciÃ³n rÃ¡pida (intentamos adivinar RPM y Fuel en varios offsets)
            # Offset 0 suele ser ID, Offset 4 o 8 suele ser RPM/Velocidad dependiendo de la versiÃ³n
            
            # Mostramos los bytes crudos para confirmar visualmente
            hex_data = buff[:16].hex()
            
            print(f"\rðŸ“¡ [{nombre_ganador}] HEX: {hex_data} ...", end="")
            time.sleep(0.1)
            
    except KeyboardInterrupt:
        print("\nListo. Usa ese nombre en tu script final.")

if __name__ == "__main__":
    escanner_total()
